generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Admin {
  id        Int      @id @default(autoincrement())
  firstName String?
  lastName  String?
  email     String   @unique
  hash      String
  role      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Log {
  id        Int      @id @default(autoincrement())
  method    String
  url       String
  status    Int
  duration  Int
  userName  String?
  userId    Int?
  userRole  String?
  ip        String?
  createdAt DateTime @default(now())
}

model User {
  id              Int      @id @default(autoincrement())
  email           String   @unique
  hash            String
  firstName       String?
  lastName        String?
  role            String?
  isEmailVerified Boolean  @default(false)

  balance  Int      @default(0)
  attempts Attempt[]
  examTokens ExamToken[] 

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  passwordResetTokens PasswordResetToken[]

  @@map("users")
}

model PasswordResetToken {
  token     String   @id
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
  expires   DateTime
  createdAt DateTime @default(now())
}

model EmailVerification {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  hash      String
  firstName String?
  lastName  String?
  role      String?
  code      String
  expires   DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("email_verifications")
}

model University {
  id     String  @id @default(cuid())
  logo   String?
  name   String
  nameAz String?
  nameEn String?
  nameRu String?

  faculties Faculty[]
  banks     QuestionBank[]

  createdAt DateTime @default(now())
}

model Subject {
  id     String  @id @default(cuid())
  name   String
  nameAz String?
  nameEn String?
  nameRu String?

  banks     QuestionBank[]
  createdAt DateTime @default(now())
}

model Faculty {
  id           String     @id @default(cuid())
  name         String
  universityId String
  university   University @relation(fields: [universityId], references: [id], onDelete: Cascade)
  courses      Course[]
}

model Course {
  id        String  @id @default(cuid())
  title     String
  facultyId String
  faculty   Faculty @relation(fields: [facultyId], references: [id], onDelete: Cascade)
  topics    Topic[]
}

model Topic {
  id       String @id @default(cuid())
  title    String
  courseId String
  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade)
  banks    QuestionBank[]
}

model QuestionBank {
  id String @id @default(cuid())

  title String
  year  Int
  price Decimal @db.Decimal(10, 2)

  universityId String
  university   University @relation(fields: [universityId], references: [id], onDelete: Cascade)

  subjectId String
  subject   Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)

  name    String
  topicId String
  topic   Topic @relation(fields: [topicId], references: [id], onDelete: Cascade)

  pdfFiles  PdfImport[]
  questions Question[]
  attempts  Attempt[]
  examTokens ExamToken[] 

  createdAt DateTime @default(now())

  @@index([universityId, subjectId, year])
}

enum PdfStatus {
  PENDING
  PARSED
  FAILED
}

model PdfImport {
  id     String @id @default(cuid())
  bankId String
  bank   QuestionBank @relation(fields: [bankId], references: [id], onDelete: Cascade)

  originalName  String
  storageKey    String
  extractedText String?
  status        PdfStatus @default(PENDING)
  createdAt     DateTime  @default(now())

  questions Question[]
}

model Question {
  id     String @id @default(cuid())
  bankId String
  bank   QuestionBank @relation(fields: [bankId], references: [id], onDelete: Cascade)

  text        String
  explanation String?
  difficulty  Int @default(1)

  correctOptionId   String?
  correctOption     QuestionOption? @relation("CorrectOption", fields: [correctOptionId], references: [id], onDelete: SetNull)
  correctAnswerText String?

  options     QuestionOption[]
  sourcePdfId String?
  sourcePdf   PdfImport? @relation(fields: [sourcePdfId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  attemptAnswers AttemptAnswer[]
}

model QuestionOption {
  id         String @id @default(cuid())
  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  text       String

  correctForQuestions Question[] @relation("CorrectOption")
  chosenInAnswers     AttemptAnswer[]

  @@unique([questionId, text])
}

enum AttemptStatus {
  IN_PROGRESS
  FINISHED
}

model Attempt {
  id String @id @default(cuid())

  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  bankId String
  bank   QuestionBank @relation(fields: [bankId], references: [id], onDelete: Cascade)

  status     AttemptStatus @default(IN_PROGRESS)
  startedAt  DateTime      @default(now())
  finishedAt DateTime?
  score      Int           @default(0)
  total      Int           @default(0)

  answers AttemptAnswer[]
}

model AttemptAnswer {
  id        String @id @default(cuid())
  attemptId String
  attempt   Attempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)

  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  selectedOptionId String
  selectedOption   QuestionOption @relation(fields: [selectedOptionId], references: [id], onDelete: Cascade)

  isCorrect Boolean
  createdAt DateTime @default(now())

  @@unique([attemptId, questionId])
}

model ExamToken {
  id        String   @id @default(cuid())
  token     String   @unique

  bankId    String
  bank      QuestionBank @relation(fields: [bankId], references: [id], onDelete: Cascade)

  userId    Int
  user      User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  expiresAt DateTime
  usedAt    DateTime?

  @@index([bankId, userId])
}
